---
layout: page
title: Docker
---

Use Docker configure, compile, and test.

## Background

The provided `Dockerfile` will build a Docker image that has CMake, gcc, and
CppUTest installed. It can be used to easily compile and test code.

The source and build directories are bind-mounted to the container. This
allows source code changes to be made on the host and easily compiled in the
container. It also allows the build results that are generated by the container
to persist after the container is stopped.

## Prerequisites

  * Docker v17.05+

## Setup

### Build Docker Image

The syntax for building a Docker image is:
```bash
# docker build --tag <image_name> <relative/path/dir/with/Dockerfile/>
```
Specify the directory that contains the Dockerfile, not the Dockerfile itself.

I prefer to tag the image very specifically in order to track changes and then
generate a user-friendly tag for use at the command line:
```bash
$ docker build --tag cpputest:3.8-2b45d38 Dockerfiles/
$ docker tag cpputest:3.8-2b45d38 cpputest
```


### Run Docker Container

A docker image can be run simply using `docker run <image_name>`, but we want to
customize several aspects of this container. In particular, we want to be able
to run both test and production builds.

This repo features two example `.env` files, one for production and one for testing:

  * test.env.example
  * production.env.example

Copy and edit each to be appropriate to your system.

The generic command for starting a container is:
```bash
# ENV_FILE=<env_file> ./docker_run.sh <image_name>
```


### Test Build

Create a `.env` file for testing:
```bash
$ cp test.env.example test.env
```
Edit this file to be appropriate to your system. Note that Docker requires
absolute paths.

Run the container with:
```bash
$ ENV_FILE=test.env ./docker_run.sh cpputest
```

Once inside the container, configure using:
```bash
$ cmake ../cpputest_intro
```
This project will compile unit tests by default.

Compile with:
```bash
$ make
```

CMake will run all test suites with:
```bash
$ ctest
# or
$ make test
```

To run individual test executables, run:
```bash
# ./bin/<test_executable>
$ ./bin/test_cpputest_intro
```

I prefer to colorize the tests' output with:
```bash
$ ./bin/test_cpputest_intro -c
```

When finished, stop the container using:
```bash
$ exit
```


### Production Build

It is important to distinguish between test and production builds. Unit tests
often override behavior of production code with mocks, custom functions, and
memory leak checks. This configuration uses a separate build directory for
production builds to ensure that test code is kept separate.

Create a `.env` file for production:
```bash
$ cp production.env.example production.env
```
Edit this file to be appropriate to your system. Note that Docker requires
absolute paths.

Run the container with:
```bash
$ ENV_FILE=production.env ./docker_run.sh cpputest
```

Once inside the container, configure using:
```bash
$ cmake ../cpputest_intro -DCOMPILE_TESTS=OFF
```
Note that unit tests are explicitly disabled.

Compile with:
```bash
$ make
```

This project illustrates unit testing on a library so there are no production
executables to run.

When finished, stop the container using:
```bash
$ exit
```
